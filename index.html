<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tilt Labyrinth RPG</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
    .emoji-label {
      position: absolute;
      font-size: 18px;
      pointer-events: none;
    }
    #hud {
      position: absolute;
      top: 5px;
      left: 5px;
      color: white;
      font-family: sans-serif;
      font-size: 14px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="hud"></div>
  <canvas id="game"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

    const canvas = document.getElementById("game");
    const engine = Engine.create();
    const world = engine.world;

    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: '#111'
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    function resizeCanvas() {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const EMOJIS = {
      hero: 'ðŸ§™',
      sword: 'ðŸ—¡ï¸',
      shield: 'ðŸ›¡ï¸',
      enemy: 'ðŸ‘¾',
      apple: 'ðŸŽ'
    };

    const labels = {};
    const hud = document.getElementById("hud");

    function makeEmojiLabel(emoji) {
      const el = document.createElement('div');
      el.className = 'emoji-label';
      el.textContent = emoji;
      document.body.appendChild(el);
      return el;
    }

    function trackEmoji(label, body) {
      const el = makeEmojiLabel(label);
      labels[body.id] = { el, body };
    }

    function updateEmojiPositions() {
      for (let id in labels) {
        const { el, body } = labels[id];
        el.style.left = (body.position.x - 10) + 'px';
        el.style.top = (body.position.y - 12) + 'px';
      }
    }

    function updateHUD() {
      hud.innerText = `Health: ${HERO.health} | Attack: ${HERO.attack} | Defense: ${HERO.defense}`;
    }

    const HERO = {
      attack: 3,
      defense: 2,
      health: 20,
      body: Bodies.circle(30, 30, 14, {
        label: 'hero',
        restitution: 0.4,
        render: { fillStyle: '#666' }
      })
    };
    trackEmoji(EMOJIS.hero, HERO.body);
    updateHUD();

    const items = [];
    function createItem(type, x, y) {
      let item = Bodies.circle(x, y, 10, {
        label: type,
        restitution: 0.4,
        render: { fillStyle: '#aaa' }
      });
      item.stats = { health: type === 'enemy' ? 10 : 0, attack: 3, defense: 1 };
      items.push(item);
      trackEmoji(EMOJIS[type], item);
      return item;
    }

    const mazeWalls = [];
    const cols = 12;
    const rows = 20;
    const cellSize = Math.min(window.innerWidth / cols, window.innerHeight / rows);
    const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));
    const directions = [[0, -1], [1, 0], [0, 1], [-1, 0]];

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function generateMaze(x, y) {
      visited[y][x] = true;
      for (const [dx, dy] of shuffle(directions)) {
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[ny][nx]) {
          const mx = (x + nx + 1) * cellSize / 2;
          const my = (y + ny + 1) * cellSize / 2;
          const vertical = dx === 0;
          mazeWalls.push(Bodies.rectangle(mx, my, vertical ? cellSize : 4, vertical ? 4 : cellSize, {
            isStatic: true,
            render: { fillStyle: '#333' }
          }));
          generateMaze(nx, ny);
        }
      }
    }

    generateMaze(0, 0);

    // Borders
    const border = [
      Bodies.rectangle(window.innerWidth / 2, -20, window.innerWidth, 40, { isStatic: true }),
      Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 20, window.innerWidth, 40, { isStatic: true }),
      Bodies.rectangle(-20, window.innerHeight / 2, 40, window.innerHeight, { isStatic: true }),
      Bodies.rectangle(window.innerWidth + 20, window.innerHeight / 2, 40, window.innerHeight, { isStatic: true })
    ];

    // Populate game
    const allObjects = [HERO.body, ...border, ...mazeWalls];

    for (let i = 0; i < 3; i++) allObjects.push(createItem('sword', Math.random() * window.innerWidth, Math.random() * window.innerHeight));
    for (let i = 0; i < 3; i++) allObjects.push(createItem('shield', Math.random() * window.innerWidth, Math.random() * window.innerHeight));
    for (let i = 0; i < 4; i++) allObjects.push(createItem('apple', Math.random() * window.innerWidth, Math.random() * window.innerHeight));
    for (let i = 0; i < 5; i++) allObjects.push(createItem('enemy', Math.random() * window.innerWidth, Math.random() * window.innerHeight));

    World.add(world, allObjects);

    Events.on(engine, 'collisionStart', event => {
      for (let pair of event.pairs) {
        const [a, b] = [pair.bodyA, pair.bodyB];
        let hero = null, other = null;

        if (a.label === 'hero') { hero = a; other = b; }
        else if (b.label === 'hero') { hero = b; other = a; }
        else continue;

        if (other.label === 'sword') {
          HERO.attack += 1;
          World.remove(world, other);
          labels[other.id].el.remove();
        } else if (other.label === 'shield') {
          HERO.defense += 1;
          World.remove(world, other);
          labels[other.id].el.remove();
        } else if (other.label === 'apple') {
          HERO.health += 3;
          World.remove(world, other);
          labels[other.id].el.remove();
        } else if (other.label === 'enemy') {
          let dmgToEnemy = Math.max(0, HERO.attack - other.stats.defense);
          let dmgToHero = Math.max(0, other.stats.attack - HERO.defense);
          other.stats.health -= dmgToEnemy;
          HERO.health -= dmgToHero;
          if (other.stats.health <= 0) {
            World.remove(world, other);
            labels[other.id].el.remove();
          }
          if (HERO.health <= 0) {
            alert("You died!");
            location.reload();
          }
        }
        updateHUD();
      }
    });

    window.addEventListener('deviceorientation', function(event) {
      const tiltX = event.gamma;
      const tiltY = event.beta;
      if (tiltX !== null && tiltY !== null) {
        engine.gravity.x = tiltX / 90;
        engine.gravity.y = tiltY / 90;
      }
    });

    (function animate() {
      updateEmojiPositions();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>
