<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tilt Labyrinth RPG (Emoji Edition)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
    .emoji-label {
      position: absolute;
      font-size: 24px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

    const canvas = document.getElementById("game");
    const engine = Engine.create();
    const world = engine.world;

    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,
        background: '#111'
      }
    });

    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    function resizeCanvas() {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const EMOJIS = {
      hero: 'üßô',
      sword: 'üó°Ô∏è',
      shield: 'üõ°Ô∏è',
      enemy: 'üëæ',
      apple: 'üçé'
    };

    const labels = {};

    function makeEmojiLabel(emoji) {
      const el = document.createElement('div');
      el.className = 'emoji-label';
      el.textContent = emoji;
      document.body.appendChild(el);
      return el;
    }

    function trackEmoji(label, body) {
      const el = makeEmojiLabel(label);
      labels[body.id] = { el, body };
    }

    function updateEmojiPositions() {
      for (let id in labels) {
        const { el, body } = labels[id];
        el.style.left = (body.position.x - 12) + 'px';
        el.style.top = (body.position.y - 16) + 'px';
      }
    }

    const HERO = {
      attack: 5,
      defense: 5,
      health: 30,
      body: Bodies.circle(100, 100, 30, {
        label: 'hero',
        restitution: 0.5,
        render: { fillStyle: '#222' }
      })
    };
    trackEmoji(EMOJIS.hero, HERO.body);

    const items = [];

    function createItem(type, x, y) {
      let item = Bodies.circle(x, y, 25, {
        isSensor: true,
        label: type,
        render: { fillStyle: '#111' }
      });
      item.stats = { health: type === 'enemy' ? 20 : 0, attack: 4, defense: 2 };
      items.push(item);
      trackEmoji(EMOJIS[type], item);
      return item;
    }

    // Generate labyrinth walls
    const walls = [];
    for (let i = 0; i < 10; i++) {
      let wall = Bodies.rectangle(
        Math.random() * window.innerWidth,
        Math.random() * window.innerHeight,
        200, 20,
        { isStatic: true, angle: Math.random() * Math.PI, render: { fillStyle: '#444' } }
      );
      walls.push(wall);
    }

    World.add(world, [
      HERO.body,
      createItem('sword', 300, 300),
      createItem('shield', 400, 500),
      createItem('apple', 200, 600),
      createItem('enemy', 600, 400),
      ...walls,
      Bodies.rectangle(window.innerWidth / 2, window.innerHeight + 50, window.innerWidth, 100, { isStatic: true }),
      Bodies.rectangle(window.innerWidth / 2, -50, window.innerWidth, 100, { isStatic: true }),
      Bodies.rectangle(-50, window.innerHeight / 2, 100, window.innerHeight, { isStatic: true }),
      Bodies.rectangle(window.innerWidth + 50, window.innerHeight / 2, 100, window.innerHeight, { isStatic: true })
    ]);

    Events.on(engine, 'collisionStart', event => {
      for (let pair of event.pairs) {
        const labels = [pair.bodyA.label, pair.bodyB.label];
        if (labels.includes('hero')) {
          let other = pair.bodyA.label === 'hero' ? pair.bodyB : pair.bodyA;
          if (!other.label) continue;

          if (other.label === 'sword') {
            HERO.attack += 2;
            World.remove(world, other);
            labels[other.id]?.el?.remove();
          } else if (other.label === 'shield') {
            HERO.defense += 2;
            World.remove(world, other);
            labels[other.id]?.el?.remove();
          } else if (other.label === 'apple') {
            HERO.health += 5;
            World.remove(world, other);
            labels[other.id]?.el?.remove();
          } else if (other.label === 'enemy') {
            let damageToEnemy = Math.max(0, HERO.attack - other.stats.defense);
            let damageToHero = Math.max(0, other.stats.attack - HERO.defense);
            other.stats.health -= damageToEnemy;
            HERO.health -= damageToHero;

            if (other.stats.health <= 0) {
              World.remove(world, other);
              labels[other.id]?.el?.remove();
            }
            if (HERO.health <= 0) {
              alert("You died!");
              location.reload();
            }
          }
        }
      }
    });

    // Gravity via tilt
    window.addEventListener('deviceorientation', function(event) {
      const tiltX = event.gamma;
      const tiltY = event.beta;
      if (tiltX !== null && tiltY !== null) {
        engine.gravity.x = tiltX / 90;
        engine.gravity.y = tiltY / 90;
      }
    });

    // Animate emoji labels
    (function animate() {
      updateEmojiPositions();
      requestAnimationFrame(animate);
    })();
  </script>
</body>
</html>
